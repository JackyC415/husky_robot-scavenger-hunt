# husky_robot-scavenger-hunt

# Overview:

The objective is to implement a robot controller that discovers randomly located objects (known as treasures) in the given environment. The goal of our ROS nodes is to print out the name and location of found treasures on the ROS console, using the objects associated (string) and the absolute position on the map. We used the following nodes: move_base(robot movement), map_server (environment), and logical camera (objects detector). To publish the treasures information to the console we use the logical camera node. The location service is managed by the moveBase node. Location mapping is controlled by a node using map_server client.

# Strategy:

Our method for finding treasures is to first create a map of all the possible points that the husky can travel to. We then send the husky to all of these points. Since these points are all the places available on the map ,the husky should find go to all the places that have treasures. The logical camera is on the husky so when the husky gets to a location containing treasure it will print out the information of it, this includes the name and location.

# Method:

The method we used to locate our treasures can be broken down using by looking at each node in depth. The mapInfo.cpp manages the map data and passes the relevant data to the subscribing nodes. moveBase.cpp is the node subscribed to mapInfo.cpp, and uses the map data to traverse the map. Simple_subs_cam_node.cpp is independent from these nodes and analyzes the area visible. If a treasure is within the camera’s vision it will print location in the form of coordinates and name in the form of a string.Upon running mapInfo.cpp the node reads the map information using the map_server. It basically reads map data found within the workspace. Using this information we calculate the points that the husky can travel to using some for loops. We store these traversable points into an vector. The usable points are found by creating the boundaries of the map and labeling all areas covered by walls as non-traversable coordinates. After, we publish the vector into a topic called WHATSUP, then moveBase.cpp subscribe to the topic and reads the vector that holds the traversable point.The node that controls the husky’s movement is moveBase.cpp. This node works by waiting for moveInfo.cpp to pass through the maps traversable points in an vector format. When moveBase.cpp receives the vector it tells the husky to go to the last point in that vector. After the Husky gets to that location; moveBase.cpp reads the next point that held in the vector. When the husky finished traversing all possible points all treasures should be located and identified using the logical camera. Simple_subs_cam_node.cpp continuously scans the environment using the camera mounted on the Husky. The camera views the area directly in front of the Husky. If a treasure object is found the node will detect the treasure object’s location and name. The name and location will be compared to a list of strings that will contain the names of all treasures found, if the treasure found is new, the information will be stored to an available string and the location and treasure name will be displayed on the ROS console. We also implemented laser, therefore there is a lesser possibility of the Husky getting wedged on an obstacle. If it is to close to a wall the husky will back up. Wall collision issues are due to inaccuracies of the Husky when estimating its position. In the presentation this issue was made evident after our first run. After implementing the laser the husky traversed the majority of the map and did not get caught on an obstacle thanks to Doctor Caprin’s idea of using twists when an object is near.

# Problems:
Our robot will eventually traverse the map but we are only given 10 minutes for the presentations. The issue stems from our programs efficiency, in specific our cost map, we suspect that the robot is not able to traverse the entire map environment within 10 minutes. Our available location vector has approximately 21 pairs of different points on the map, running at an iteration of 21 times with an duration of 20 seconds per point, it would take approximately 420 seconds to complete the vector of traversable points this is not taking into accounts any delays. We have to account for system delays such as when the husky waits for action client commands. The problem is Twist command does not execute right away, because of run-time conflicts with move_base. Therefore, there is some lag when backing up after an obstacle is found. Moreover the twist commands sometimes get overwritten by movebase’s commands. 

# Result:
Based on our initial tests using the given test map we expect to get 100% of all treasures within the given time. In our test map our robot found 5 out of the 5 treasures on the map within 10 minutes. Since the map will be randomized the results of the actual test may yield better or worse results. In the final test using the new map we found two treasures within the given time. It avoided a few walls and could have traversed the majority of the map if more time were given.
